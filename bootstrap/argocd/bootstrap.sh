#!/usr/bin/env bash
set -euo pipefail

# Bootstrap Argo CD and optionally apply a root "app-of-apps".
#
# Configuration is via env vars (can be loaded from a .env file).
#
# Required tools: kubectl, helm
#
# Typical usage:
#   ORG_SLUG=aethericforge ENV=kubeadm ./bootstrap/argocd/bootstrap.sh
#
# Or:
#   ./bootstrap/argocd/bootstrap.sh --env-file bootstrap/env/kubeadm.env

ENV_FILE=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --env-file)
      ENV_FILE="$2"; shift 2 ;;
    *)
      echo "Unknown arg: $1" >&2; exit 2 ;;
  esac
done

if [[ -n "${ENV_FILE}" ]]; then
  # shellcheck disable=SC1090
  source "${ENV_FILE}"
fi

# ---- Helpers ----------------------------------------------------------------
need() { command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 1; }; }

# ---- Cert-manager CRDs (bootstrap-owned) ------------------------------------
CERT_MANAGER_VERSION="${CERT_MANAGER_VERSION:-v1.14.4}"
CERT_MANAGER_CRDS_MODE="${CERT_MANAGER_CRDS_MODE:-release}" # release | helm-template

need curl

install_cert_manager_crds() {
  echo ">>> Installing cert-manager CRDs only (${CERT_MANAGER_VERSION}, mode=${CERT_MANAGER_CRDS_MODE})"

  kubectl create namespace cert-manager --dry-run=client -o yaml | kubectl apply -f - >/dev/null

  case "${CERT_MANAGER_CRDS_MODE}" in
    release)
      # Preferred: pinned, stable, no helm-side effects
      kubectl apply -f "https://github.com/cert-manager/cert-manager/releases/download/${CERT_MANAGER_VERSION}/cert-manager.crds.yaml"
      ;;
    helm-template)
      # Alternative: render CRDs via Helm (still applies CRDs only)
      helm repo add jetstack https://charts.jetstack.io >/dev/null 2>&1 || true
      helm repo update >/dev/null

      helm template cert-manager-crds jetstack/cert-manager \
        --version "${CERT_MANAGER_VERSION#v}" \
        --namespace cert-manager \
        --include-crds \
      | kubectl apply -f -
      ;;
    *)
      echo "ERROR: Unknown CERT_MANAGER_CRDS_MODE=${CERT_MANAGER_CRDS_MODE} (expected: release|helm-template)" >&2
      exit 1
      ;;
  esac

  echo ">>> Waiting for CRDs to be Established"
  # Wait only on cert-manager CRDs (avoid hanging on unrelated CRDs)
  mapfile -t cm_crds < <(kubectl get crd -o name | grep -E '\.cert-manager\.io$' || true)
  if [[ ${#cm_crds[@]} -gt 0 ]]; then
    kubectl wait --for=condition=Established --timeout=60s "${cm_crds[@]}"
  fi
}

create_cloudflare_token_secret() {
  if [[ -n "${CLOUDFLARE_API_TOKEN_FILE}" ]]; then
    echo ">>> Creating Cloudflare API token secret: ${CLOUDFLARE_API_TOKEN_SECRET_NAMESPACE}/${CLOUDFLARE_API_TOKEN_SECRET_NAME}"
    if [[ ! -f "${CLOUDFLARE_API_TOKEN_FILE}" ]]; then
      echo "ERROR: Cloudflare token file not found: ${CLOUDFLARE_API_TOKEN_FILE}" >&2
      exit 1
    fi
    kubectl create namespace "${CLOUDFLARE_API_TOKEN_SECRET_NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f - >/dev/null
    CF_TOKEN="$(tr -d '\n' < "${CLOUDFLARE_API_TOKEN_FILE}")"
    if [[ -z "${CF_TOKEN}" ]]; then
      echo "ERROR: Cloudflare token file is empty: ${CLOUDFLARE_API_TOKEN_FILE}" >&2
      exit 1
    fi
    kubectl -n "${CLOUDFLARE_API_TOKEN_SECRET_NAMESPACE}" create secret generic "${CLOUDFLARE_API_TOKEN_SECRET_NAME}" \
      --from-literal=api-token="${CF_TOKEN}" \
      --dry-run=client -o yaml | kubectl apply -f - >/dev/null
  fi
}

# ---- Customizable inputs (with sensible defaults) ---------------------------
ORG_SLUG="${ORG_SLUG:-aethericforge}"
ENV="${ENV:-kubeadm}"
APPLY_ROOT_APP="${APPLY_ROOT_APP:-true}"

PHASE="${PHASE:-gitops}"

# Optional ingress hooks (only used when PHASE=ingress|all)
INGRESS_INSTALL_SCRIPT="${INGRESS_INSTALL_SCRIPT:-bootstrap/ingress/install.sh}"
ARGOCD_INGRESS_MANIFEST="${ARGOCD_INGRESS_MANIFEST:-bootstrap/argocd/ingress.yaml}"

ARGO_NAMESPACE="${ARGO_NAMESPACE:-argocd}"
PHASE="${PHASE:-gitops}"

# Optional: repo-scoped known_hosts file (generated by bootstrap.py for private repos)
SSH_KNOWN_HOSTS_FILE="${SSH_KNOWN_HOSTS_FILE:-}"
# Optional: SSH key for private repo access + Argo repository secret name
SSH_PRIVATE_KEY_FILE="${SSH_PRIVATE_KEY_FILE:-}"
REPO_SSH_SECRET_NAME="${REPO_SSH_SECRET_NAME:-repo-git-ssh}"

# Optional: Cloudflare API token file for DNS-01 issuance
CLOUDFLARE_API_TOKEN_FILE="${CLOUDFLARE_API_TOKEN_FILE:-}"
CLOUDFLARE_API_TOKEN_SECRET_NAME="${CLOUDFLARE_API_TOKEN_SECRET_NAME:-cloudflare-api-token}"
CLOUDFLARE_API_TOKEN_SECRET_NAMESPACE="${CLOUDFLARE_API_TOKEN_SECRET_NAMESPACE:-cert-manager}"

# Where the GitOps root app lives
ROOT_APP_PATH="${ROOT_APP_PATH:-gitops/clusters/${ENV}/root-app.yaml}"

# Helm chart version (pin for reproducibility)
ARGO_HELM_CHART_VERSION="${ARGO_HELM_CHART_VERSION:-7.7.12}"

# Values layering (base + optional overrides)
VALUES_BASE="${VALUES_BASE:-bootstrap/argocd/values.yaml}"
VALUES_ORG="${VALUES_ORG:-bootstrap/argocd/values.${ORG_SLUG}.yaml}"
VALUES_ENV="${VALUES_ENV:-bootstrap/argocd/values.${ENV}.yaml}"

# Whether to apply the root app-of-apps after install
APPLY_ROOT_APP="${APPLY_ROOT_APP:-true}"


need kubectl
need helm

echo ">>> ORG_SLUG=${ORG_SLUG}"
echo ">>> ENV=${ENV}"
echo ">>> ARGO_NAMESPACE=${ARGO_NAMESPACE}"
echo ">>> ROOT_APP_PATH=${ROOT_APP_PATH}"

echo ">>> Adding Argo Helm repo"
helm repo add argo https://argoproj.github.io/argo-helm >/dev/null 2>&1 || true
helm repo update >/dev/null

echo ">>> Ensuring namespace exists: ${ARGO_NAMESPACE}"
kubectl create namespace "${ARGO_NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f - >/dev/null

# Build Helm -f args list (base + optional overrides)
VALUES_ARGS=()
if [[ -f "${VALUES_BASE}" ]]; then VALUES_ARGS+=(-f "${VALUES_BASE}"); else
  echo "ERROR: base values file not found: ${VALUES_BASE}" >&2; exit 1
fi
if [[ -f "${VALUES_ORG}" ]]; then VALUES_ARGS+=(-f "${VALUES_ORG}"); fi
if [[ -f "${VALUES_ENV}" ]]; then VALUES_ARGS+=(-f "${VALUES_ENV}"); fi

if [[ "${PHASE}" != "ingress" ]]; then
  install_cert_manager_crds
  create_cloudflare_token_secret

  echo ">>> Installing Argo CD via Helm (chart ${ARGO_HELM_CHART_VERSION})"
  helm upgrade --install argocd argo/argo-cd \
    --namespace "${ARGO_NAMESPACE}" \
    --create-namespace \
    --version "${ARGO_HELM_CHART_VERSION}" \
    "${VALUES_ARGS[@]}" \
    --set dex.enabled=false \
    --wait
else
  echo ">>> PHASE=ingress: skipping ArgoCD install"
fi

echo ">>> Argo CD install complete"

if [[ -n "${SSH_PRIVATE_KEY_FILE}" ]]; then
  if [[ ! -f "${SSH_PRIVATE_KEY_FILE}" ]]; then
    echo "ERROR: SSH private key file not found: ${SSH_PRIVATE_KEY_FILE}" >&2
    exit 1
  fi
  # Determine repo URL for the ArgoCD repo secret
  REPO_URL="${GIT_REPO_URL:-}"
  if [[ -z "${REPO_URL}" && -n "${GITHUB_REPO:-}" ]]; then
    if [[ "${REPO_VISIBILITY:-public}" == "private" ]]; then
      REPO_URL="git@github.com:${GITHUB_REPO}.git"
    else
      REPO_URL="https://github.com/${GITHUB_REPO}.git"
    fi
  fi
  if [[ -z "${REPO_URL}" ]]; then
    echo "ERROR: Cannot create repo secret: GIT_REPO_URL (or GITHUB_REPO) is not set" >&2
    exit 1
  fi
  echo ">>> Creating/updating ArgoCD repo secret: ${ARGO_NAMESPACE}/${REPO_SSH_SECRET_NAME}"
  SSH_KEY="$(cat "${SSH_PRIVATE_KEY_FILE}")"
  if [[ -z "${SSH_KEY}" ]]; then
    echo "ERROR: SSH key file is empty: ${SSH_PRIVATE_KEY_FILE}" >&2
    exit 1
  fi
  KH=""
  if [[ -n "${SSH_KNOWN_HOSTS_FILE}" && -f "${SSH_KNOWN_HOSTS_FILE}" ]]; then
    KH="$(cat "${SSH_KNOWN_HOSTS_FILE}")"
  fi
  # Use a manifest to avoid kubectl create secret limitations for multiline values
  cat <<EOF | kubectl -n "${ARGO_NAMESPACE}" apply -f - >/dev/null
apiVersion: v1
kind: Secret
metadata:
  name: ${REPO_SSH_SECRET_NAME}
  labels:
    argocd.argoproj.io/secret-type: repository
type: Opaque
stringData:
  type: git
  url: ${REPO_URL}
  sshPrivateKey: |
$(printf "%s\n" "${SSH_KEY}" | sed 's/^/    /')
  sshKnownHosts: |
$(printf "%s\n" "${KH}" | sed 's/^/    /')
EOF
  echo ">>> Restarting argocd-repo-server to pick up repo secret changes"
  kubectl -n "${ARGO_NAMESPACE}" rollout restart deploy/argocd-repo-server >/dev/null
  kubectl -n "${ARGO_NAMESPACE}" rollout status deploy/argocd-repo-server --timeout=120s >/dev/null
fi

if [[ "${APPLY_ROOT_APP}" == "true" ]]; then
  if [[ -f "${ROOT_APP_PATH}" ]]; then
    
    if grep -qE '^\s*kind:\s*\S+' "${ROOT_APP_PATH}"; then
      if [[ "${PHASE}" != "ingress" ]]; then
        echo ">>> Applying root app: ${ROOT_APP_PATH}"
        kubectl apply -f "${ROOT_APP_PATH}"
      else
        echo ">>> PHASE=ingress: skipping root app apply"
      fi
    else
      echo ">>> Root app is empty; skipping apply."
    fi
    echo ">>> Root app applied."
  else
    echo "ERROR: root app not found at ${ROOT_APP_PATH}" >&2
    echo "       Set ROOT_APP_PATH or create the file." >&2
    exit 1
  fi
else
  echo ">>> Skipping root app apply (APPLY_ROOT_APP=false)"
fi

if [[ "${PHASE}" == "ingress" || "${PHASE}" == "all" ]]; then
  echo ">>> Ingress phase starting"

  if [[ -f "${INGRESS_INSTALL_SCRIPT}" ]]; then
    echo ">>> Running ingress install: ${INGRESS_INSTALL_SCRIPT}"
    bash "${INGRESS_INSTALL_SCRIPT}"
  else
    echo ">>> No ingress install script found, skipping"
  fi

#  if [[ -f "${ARGOCD_INGRESS_MANIFEST}" ]]; then
#    echo ">>> Applying Argo CD ingress: ${ARGOCD_INGRESS_MANIFEST}"
#    kubectl apply -f "${ARGOCD_INGRESS_MANIFEST}"
#  else
#    echo ">>> No Argo CD ingress manifest found, skipping"
#  fi

  echo ">>> Ingress phase complete"
fi

echo ">>> Done."

