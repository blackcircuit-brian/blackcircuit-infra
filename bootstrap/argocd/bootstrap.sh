#!/usr/bin/env bash
set -euo pipefail

# Bootstrap Argo CD and optionally apply a root "app-of-apps".
#
# Configuration is via env vars (can be loaded from a .env file).
#
# Required tools: kubectl, helm
#
# Typical usage:
#   ORG_SLUG=aethericforge ENV=test-k3d ./bootstrap/argocd/bootstrap.sh
#
# Or:
#   ./bootstrap/argocd/bootstrap.sh --env-file bootstrap/env/test-k3d.env

ENV_FILE=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --env-file)
      ENV_FILE="$2"; shift 2 ;;
    *)
      echo "Unknown arg: $1" >&2; exit 2 ;;
  esac
done

if [[ -n "${ENV_FILE}" ]]; then
  # shellcheck disable=SC1090
  source "${ENV_FILE}"
fi

# ---- Customizable inputs (with sensible defaults) ---------------------------
ORG_SLUG="${ORG_SLUG:-aethericforge}"
ENV="${ENV:-test-k3d}"
APPLY_ROOT_APP="${APPLY_ROOT_APP:-true}"

PHASE="${PHASE:-gitops}"

# Optional ingress hooks (only used when PHASE=ingress|all)
INGRESS_INSTALL_SCRIPT="${INGRESS_INSTALL_SCRIPT:-bootstrap/ingress/install.sh}"
ARGOCD_INGRESS_MANIFEST="${ARGOCD_INGRESS_MANIFEST:-bootstrap/argocd/ingress.yaml}"

ARGO_NAMESPACE="${ARGO_NAMESPACE:-argocd}"
PHASE="${PHASE:-gitops}"

# Optional: repo-scoped known_hosts file (generated by bootstrap.py for private repos)
SSH_KNOWN_HOSTS_FILE="${SSH_KNOWN_HOSTS_FILE:-}"

# Optional: SSH private key file for creating ArgoCD repo secret (private repos)
SSH_PRIVATE_KEY_FILE="${SSH_PRIVATE_KEY_FILE:-}"
REPO_SSH_SECRET_NAME="${REPO_SSH_SECRET_NAME:-repo-git-ssh}"

# Where the GitOps root app lives
ROOT_APP_PATH="${ROOT_APP_PATH:-gitops/clusters/${ENV}/root-app.yaml}"

# Helm chart version (pin for reproducibility)
ARGO_HELM_CHART_VERSION="${ARGO_HELM_CHART_VERSION:-7.7.12}"

# Values layering (base + optional overrides)
VALUES_BASE="${VALUES_BASE:-bootstrap/argocd/values.yaml}"
VALUES_ORG="${VALUES_ORG:-bootstrap/argocd/values.${ORG_SLUG}.yaml}"
VALUES_ENV="${VALUES_ENV:-bootstrap/argocd/values.${ENV}.yaml}"

# Whether to apply the root app-of-apps after install
APPLY_ROOT_APP="${APPLY_ROOT_APP:-true}"

# ---- Helpers ----------------------------------------------------------------
need() { command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 1; }; }

need kubectl
need helm


ensure_argocd_repo_ssh_secret() {
  # Creates/updates the ArgoCD "repository" secret for SSH-based repos.
  # This avoids a manual step after teardown (repo-git-ssh).
  if [[ -z "${GIT_REPO_URL:-}" ]]; then
    return 0
  fi
  if [[ "${GIT_REPO_URL}" != git@* ]]; then
    return 0
  fi
  if [[ -z "${SSH_PRIVATE_KEY_FILE}" ]]; then
    echo ">>> Private repo URL detected but SSH_PRIVATE_KEY_FILE is not set; skipping repo secret creation"
    return 0
  fi
  if [[ ! -f "${SSH_PRIVATE_KEY_FILE}" ]]; then
    echo "ERROR: SSH_PRIVATE_KEY_FILE not found: ${SSH_PRIVATE_KEY_FILE}" >&2
    exit 1
  fi

  echo ">>> Ensuring ArgoCD repo SSH secret: ${REPO_SSH_SECRET_NAME} (url=${GIT_REPO_URL})"

  secret_args=(create secret generic "${REPO_SSH_SECRET_NAME}"
    --namespace "${ARGO_NAMESPACE}"
    --from-literal=type=git
    --from-literal=url="${GIT_REPO_URL}"
    --from-file=sshPrivateKey="${SSH_PRIVATE_KEY_FILE}"
  )

  if [[ -n "${SSH_KNOWN_HOSTS_FILE}" ]]; then
    if [[ -f "${SSH_KNOWN_HOSTS_FILE}" ]]; then
      secret_args+=(--from-file=sshKnownHosts="${SSH_KNOWN_HOSTS_FILE}")
    else
      echo "WARN: SSH_KNOWN_HOSTS_FILE set but file not found: ${SSH_KNOWN_HOSTS_FILE} (continuing)" >&2
    fi
  fi

  kubectl "${secret_args[@]}" --dry-run=client -o yaml | kubectl apply -f -
  kubectl -n "${ARGO_NAMESPACE}" label secret "${REPO_SSH_SECRET_NAME}" argocd.argoproj.io/secret-type=repository --overwrite >/dev/null

  # Kick repo-server so it re-reads repo credentials immediately
  if kubectl -n "${ARGO_NAMESPACE}" get deploy argocd-repo-server >/dev/null 2>&1; then
    echo ">>> Restarting argocd-repo-server to pick up repo credentials"
    kubectl -n "${ARGO_NAMESPACE}" rollout restart deploy/argocd-repo-server
    kubectl -n "${ARGO_NAMESPACE}" rollout status deploy/argocd-repo-server --timeout=120s
  fi
}

# ---- Cert-manager CRDs (bootstrap-owned) ------------------------------------
CERT_MANAGER_VERSION="${CERT_MANAGER_VERSION:-v1.14.4}"
CERT_MANAGER_CRDS_MODE="${CERT_MANAGER_CRDS_MODE:-release}" # release | helm-template

need curl

install_cert_manager_crds() {
  echo ">>> Installing cert-manager CRDs only (${CERT_MANAGER_VERSION}, mode=${CERT_MANAGER_CRDS_MODE})"

  kubectl create namespace cert-manager --dry-run=client -o yaml | kubectl apply -f - >/dev/null

  case "${CERT_MANAGER_CRDS_MODE}" in
    release)
      # Preferred: pinned, stable, no helm-side effects
      kubectl apply -f "https://github.com/cert-manager/cert-manager/releases/download/${CERT_MANAGER_VERSION}/cert-manager.crds.yaml"
      ;;
    helm-template)
      # Alternative: render CRDs via Helm (still applies CRDs only)
      helm repo add jetstack https://charts.jetstack.io >/dev/null 2>&1 || true
      helm repo update >/dev/null

      helm template cert-manager-crds jetstack/cert-manager \
        --version "${CERT_MANAGER_VERSION#v}" \
        --namespace cert-manager \
        --include-crds \
      | kubectl apply -f -
      ;;
    *)
      echo "ERROR: Unknown CERT_MANAGER_CRDS_MODE=${CERT_MANAGER_CRDS_MODE} (expected: release|helm-template)" >&2
      exit 1
      ;;
  esac

  echo ">>> Waiting for CRDs to be Established"
  # Wait only on cert-manager CRDs (avoid hanging on unrelated CRDs)
  mapfile -t cm_crds < <(kubectl get crd -o name | grep -E '\.cert-manager\.io$' || true)
  if [[ ${#cm_crds[@]} -gt 0 ]]; then
    kubectl wait --for=condition=Established --timeout=60s "${cm_crds[@]}"
  fi
}
echo ">>> ORG_SLUG=${ORG_SLUG}"
echo ">>> ENV=${ENV}"
echo ">>> ARGO_NAMESPACE=${ARGO_NAMESPACE}"
echo ">>> ROOT_APP_PATH=${ROOT_APP_PATH}"

echo ">>> Adding Argo Helm repo"
helm repo add argo https://argoproj.github.io/argo-helm >/dev/null 2>&1 || true
helm repo update >/dev/null

echo ">>> Ensuring namespace exists: ${ARGO_NAMESPACE}"
kubectl create namespace "${ARGO_NAMESPACE}" --dry-run=client -o yaml | kubectl apply -f - >/dev/null

# Build Helm -f args list (base + optional overrides)
VALUES_ARGS=()
if [[ -f "${VALUES_BASE}" ]]; then VALUES_ARGS+=(-f "${VALUES_BASE}"); else
  echo "ERROR: base values file not found: ${VALUES_BASE}" >&2; exit 1
fi
if [[ -f "${VALUES_ORG}" ]]; then VALUES_ARGS+=(-f "${VALUES_ORG}"); fi
if [[ -f "${VALUES_ENV}" ]]; then VALUES_ARGS+=(-f "${VALUES_ENV}"); fi

if [[ "${PHASE}" != "ingress" ]]; then
  echo ">>> Installing cert-manager CRDs only"
  install_cert_manager_crds

  echo ">>> Installing Argo CD via Helm (chart ${ARGO_HELM_CHART_VERSION})"
  helm upgrade --install argocd argo/argo-cd \
    --namespace "${ARGO_NAMESPACE}" \
    --create-namespace \
    --version "${ARGO_HELM_CHART_VERSION}" \
    "${VALUES_ARGS[@]}" \
    --set dex.enabled=false \
    --wait
else
  echo ">>> PHASE=ingress: skipping ArgoCD install"
fi

echo ">>> Argo CD install complete"

# If using an SSH-based repo, ensure the repo secret exists before applying the root app
ensure_argocd_repo_ssh_secret

if [[ "${APPLY_ROOT_APP}" == "true" ]]; then
  if [[ -f "${ROOT_APP_PATH}" ]]; then
    
    if grep -qE '^\s*kind:\s*\S+' "${ROOT_APP_PATH}"; then
      if [[ "${PHASE}" != "ingress" ]]; then
        echo ">>> Applying root app: ${ROOT_APP_PATH}"
        kubectl apply -f "${ROOT_APP_PATH}"
      else
        echo ">>> PHASE=ingress: skipping root app apply"
      fi
    else
      echo ">>> Root app is empty; skipping apply."
    fi
    echo ">>> Root app applied."
  else
    echo "ERROR: root app not found at ${ROOT_APP_PATH}" >&2
    echo "       Set ROOT_APP_PATH or create the file." >&2
    exit 1
  fi
else
  echo ">>> Skipping root app apply (APPLY_ROOT_APP=false)"
fi

if [[ "${PHASE}" == "ingress" || "${PHASE}" == "all" ]]; then
  echo ">>> Ingress phase starting"

  if [[ -f "${INGRESS_INSTALL_SCRIPT}" ]]; then
    echo ">>> Running ingress install: ${INGRESS_INSTALL_SCRIPT}"
    bash "${INGRESS_INSTALL_SCRIPT}"
  else
    echo ">>> No ingress install script found, skipping"
  fi

#  if [[ -f "${ARGOCD_INGRESS_MANIFEST}" ]]; then
#    echo ">>> Applying Argo CD ingress: ${ARGOCD_INGRESS_MANIFEST}"
#    kubectl apply -f "${ARGOCD_INGRESS_MANIFEST}"
#  else
#    echo ">>> No Argo CD ingress manifest found, skipping"
#  fi

  echo ">>> Ingress phase complete"
fi

echo ">>> Done."

