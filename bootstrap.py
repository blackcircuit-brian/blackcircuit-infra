#!/usr/bin/env python3
"""
bootstrap.py

Interactive front-end for bootstrap/argocd/bootstrap.sh.

- Prompts for key inputs with defaults
- Writes a .env file
- Invokes bootstrap.sh with --env-file

Stdlib-only on purpose for OSS friendliness.
"""

from __future__ import annotations

import re
import shlex
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Optional


VALID_PHASES = ("gitops", "ingress", "all")

def normalize_github_repo(value: str) -> str:
    """
    Normalize GitHub repo input to org/repo (no .git).
    Accepts:
      - org/repo
      - https://github.com/org/repo(.git)
      - git@github.com:org/repo(.git)
    """
    v = value.strip()
    if not v:
        return ""

    # https://github.com/org/repo(.git)
    m = re.match(r"^https?://github\.com/([^/]+)/([^/]+?)(?:\.git)?/?$", v)
    if m:
        return f"{m.group(1)}/{m.group(2)}"

    # git@github.com:org/repo(.git)
    m = re.match(r"^git@github\.com:([^/]+)/([^/]+?)(?:\.git)?$", v)
    if m:
        return f"{m.group(1)}/{m.group(2)}"

    # org/repo(.git)
    m = re.match(r"^([^/]+)/([^/]+?)(?:\.git)?$", v)
    if m:
        return f"{m.group(1)}/{m.group(2)}"

    raise ValueError(f"Unrecognized GitHub repo format: {value!r}")


def github_clone_url(org_repo: str, visibility: str) -> str:
    """
    Return the clone URL for a normalized org/repo and visibility.
    """
    if not org_repo:
        return ""
    if visibility == "private":
        return f"git@github.com:{org_repo}.git"
    return f"https://github.com/{org_repo}.git"

@dataclass
class BootstrapConfig:
    org_slug: str = "aethericforge"
    env: str = "test-k3d"
    argo_namespace: str = "argocd"
    phase: str = "gitops"
    apply_root_app: bool = True
    root_app_path: str = ""  # derived if empty

    # Future-friendly fields (not necessarily used by bootstrap.sh today)
    repo_visibility: str = "public"  # public|private
    github_repo: str = ""           # org/repo or full URL
    repo_ref: str = "main"          # branch/tag/sha

    def normalize(self) -> None:
        if self.phase not in VALID_PHASES:
            raise ValueError(f"Invalid PHASE: {self.phase}. Expected one of: {', '.join(VALID_PHASES)}")

        # Derive ROOT_APP_PATH if not set
        if not self.root_app_path.strip():
            self.root_app_path = f"gitops/clusters/{self.env}/root-app.yaml"

        # Normalize booleans to "true"/"false" later
        self.org_slug = self.org_slug.strip()
        self.env = self.env.strip()
        self.argo_namespace = self.argo_namespace.strip()
        self.repo_visibility = self.repo_visibility.strip().lower()
        self.github_repo = self.github_repo.strip()
        self.repo_ref = self.repo_ref.strip()


def _prompt(text: str, default: Optional[str] = None) -> str:
    suffix = f" [{default}]" if default is not None and default != "" else ""
    while True:
        val = input(f"{text}{suffix}: ").strip()
        if val:
            return val
        if default is not None:
            return default


def _prompt_bool(text: str, default: bool) -> bool:
    d = "y" if default else "n"
    while True:
        val = input(f"{text} [y/n] [{d}]: ").strip().lower()
        if not val:
            return default
        if val in ("y", "yes", "true", "1"):
            return True
        if val in ("n", "no", "false", "0"):
            return False
        print("Please enter y or n.")


def _prompt_choice(text: str, choices: tuple[str, ...], default: str) -> str:
    choices_str = "/".join(choices)
    while True:
        val = input(f"{text} ({choices_str}) [{default}]: ").strip().lower()
        if not val:
            return default
        if val in choices:
            return val
        print(f"Please choose one of: {choices_str}")


def _parse_env_file(path: Path) -> Dict[str, str]:
    """
    Minimal .env parser:
    - KEY=VALUE
    - ignores comments and blank lines
    - strips surrounding quotes if present
    """
    out: Dict[str, str] = {}
    if not path.exists():
        return out

    for line in path.read_text(encoding="utf-8").splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if "=" not in line:
            continue
        k, v = line.split("=", 1)
        k = k.strip()
        v = v.strip()
        if (v.startswith('"') and v.endswith('"')) or (v.startswith("'") and v.endswith("'")):
            v = v[1:-1]
        out[k] = v
    return out


def _quote_env_value(v: str) -> str:
    """
    Quote values safely for .env consumption.
    We always double-quote and escape embedded double quotes and backslashes.
    """
    v = v.replace("\\", "\\\\").replace('"', '\\"')
    return f'"{v}"'


def _write_env_file(path: Path, values: Dict[str, str]) -> None:
    lines = [
        "# Generated by bootstrap.py",
        "# You can edit this file and re-run bootstrap.py to reuse values.",
        "",
    ]
    
    for k in sorted(values.keys()):
        lines.append(f"{k}={_quote_env_value(values[k])}")
    lines.append("")  # trailing newline

    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text("\n".join(lines), encoding="utf-8")


def _find_repo_root(start: Path) -> Path:
    """
    Walk upward until we find a .git directory or fail.
    """
    cur = start.resolve()
    for _ in range(20):
        if (cur / ".git").exists():
            return cur
        if cur.parent == cur:
            break
        cur = cur.parent
    # Fall back to start's parent; still useful for local usage
    return start.resolve()


def _validate_slug(value: str, field: str) -> None:
    # Keep it conservative: alnum + dash only
    if not re.fullmatch(r"[a-zA-Z0-9][a-zA-Z0-9\-]*", value):
        raise ValueError(f"{field} must be alphanumeric/dash (start with alnum). Got: {value!r}")


def main() -> int:
    here = Path(__file__).resolve()
    repo_root = _find_repo_root(here.parent)

    bootstrap_sh = repo_root / "bootstrap" / "argocd" / "bootstrap.sh"
    if not bootstrap_sh.exists():
        print(f"ERROR: Could not find bootstrap.sh at: {bootstrap_sh}", file=sys.stderr)
        return 2

    default_env_file = repo_root / "bootstrap" / "env" / "test-k3d.env"
    print(f"Repo root: {repo_root}")
    print(f"Bootstrap script: {bootstrap_sh}")
    print("")

    env_file_str = _prompt("Env file path to write", str(default_env_file))
    env_path = (repo_root / env_file_str).resolve() if not Path(env_file_str).is_absolute() else Path(env_file_str)
    existing = _parse_env_file(env_path)

    # Seed defaults from existing env if present
    cfg = BootstrapConfig(
        org_slug=existing.get("ORG_SLUG", "aethericforge"),
        env=existing.get("ENV", "test-k3d"),
        argo_namespace=existing.get("ARGO_NAMESPACE", existing.get("ARGOCD_NAMESPACE", "argocd")),
        phase=existing.get("PHASE", "gitops"),
        apply_root_app=(existing.get("APPLY_ROOT_APP", "true").lower() in ("true", "1", "yes", "y")),
        root_app_path=existing.get("ROOT_APP_PATH", ""),
        repo_visibility=existing.get("REPO_VISIBILITY", "public"),
        github_repo=existing.get("GITHUB_REPO", ""),
        repo_ref=existing.get("REPO_REF", "main"),
    )

    print("=== Bootstrap configuration ===")
    cfg.org_slug = _prompt("Org slug (values.<org>.yaml selector)", cfg.org_slug)
    _validate_slug(cfg.org_slug, "ORG_SLUG")

    cfg.env = _prompt("Environment name (values.<env>.yaml selector)", cfg.env)
    _validate_slug(cfg.env, "ENV")

    cfg.argo_namespace = _prompt("Argo CD namespace", cfg.argo_namespace)
    cfg.phase = _prompt_choice("Phase", VALID_PHASES, cfg.phase if cfg.phase in VALID_PHASES else "gitops")

    cfg.apply_root_app = _prompt_bool("Apply root app-of-apps", cfg.apply_root_app)

    # Root app path defaults to gitops/clusters/<env>/root-app.yaml
    default_root = f"gitops/clusters/{cfg.env}/root-app.yaml"
    cfg.root_app_path = _prompt("Root app path", cfg.root_app_path or default_root)

    # GitHub inputs (future friendly, and useful for README / next steps)
    cfg.repo_visibility = _prompt_choice("GitHub repo visibility", ("public", "private"), cfg.repo_visibility if cfg.repo_visibility in ("public", "private") else "public")

    raw_repo = _prompt("GitHub repo (org/repo or URL) [optional]", cfg.github_repo)
    try:
        cfg.github_repo = normalize_github_repo(raw_repo) if raw_repo else ""
    except ValueError as e:
        print(str(e), file=sys.stderr)
        return 2

    cfg.normalize()

    # Build .env values. Keep keys aligned with bootstrap.sh expectations.
    env_values: Dict[str, str] = {
        "ORG_SLUG": cfg.org_slug,
        "ENV": cfg.env,
        "ARGO_NAMESPACE": cfg.argo_namespace,
        "PHASE": cfg.phase,
        "APPLY_ROOT_APP": "true" if cfg.apply_root_app else "false",
        "ROOT_APP_PATH": cfg.root_app_path,

        # Future-friendly keys (safe if bootstrap.sh ignores them)
        "REPO_VISIBILITY": cfg.repo_visibility,
        "GITHUB_REPO": cfg.github_repo,
        "REPO_REF": cfg.repo_ref,
    }

    repo_url = github_clone_url(cfg.github_repo, cfg.repo_visibility)
    env_values["GIT_REPO_URL"] = repo_url

    _write_env_file(env_path, env_values)
    print("")
    print(f"Wrote env file: {env_path}")
    print("")

    # Run bootstrap.sh
    cmd = ["bash", str(bootstrap_sh), "--env-file", str(env_path)]
    print("Running:")
    print("  " + " ".join(shlex.quote(c) for c in cmd))
    print("")

    try:
        subprocess.run(cmd, cwd=str(repo_root), check=True)
    except subprocess.CalledProcessError as e:
        print(f"\nBootstrap failed with exit code {e.returncode}", file=sys.stderr)
        return e.returncode

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
